// Gravitational/Game objects
"use strict";
// globals: window, Vector

var SC = window.SC || {};

// single object

SC.go = function (aName, aPosition, aDirection, aRight, aSpeed, aRadius, aMass, aColor) {
    // single gravitational object
    this.name = aName;
    this.pos = (aPosition || Vector.create([0, 0, 0])).dup();
    this.dir = (aDirection || Vector.i).dup();
    this.right = (aRight || Vector.i).dup();
    this.speed = (aSpeed || Vector.create([0, 0, 0])).dup();
    this.radius = aRadius || 1;
    this.mass = aMass || 1000;
    this.fuel = 0;
    this.fuelMax = 0;
    this.fuelConsumption = 0;
    this.color = aColor || 'white';
    this.fgmUpdates = 0;
    this.fgmTime = 0;
    this.fgm = Vector.create([0, 0, 0]);   // F * g / m (if you multiply it by dt you get dv, it only need to be update once every few minutes)
    this.thrust = null; // force vector generated by thrusters
    this.thrustMax = null; // 1200N for player
    this.rot = null; // persistent rotation [roll, pitch, yaw], use null if rotation of object is not important, currently only SC.player has rotation
    this.model = null; // station,beacon,planet,...
    this.refuel = false; // if it offers refueling for player
    this.lidarable = true; // if it is possible to find it on lidar
    this.maxRenderDistance = 1e20; // beyond this distance object will not be rendered
    this.maxModelRenderDistance = 1e20; // beyond this distance model will not be rendered
};

SC.go.prototype.copyFrom = function (aSrc) {
    // copy data from source
    this.name = aSrc.name;
    this.pos = Vector.create(aSrc.pos.elements);
    this.dir = Vector.create(aSrc.dir.elements);
    this.right = Vector.create(aSrc.right.elements);
    this.speed = Vector.create(aSrc.speed.elements);
    this.radius = aSrc.radius;
    this.mass = aSrc.mass;
    this.fuel = aSrc.fuel;
    this.fuelMax = aSrc.fuelMax;
    this.fuelConsumption = aSrc.fuelConsumption;
    this.color = aSrc.color;
    this.fgmUpdates = aSrc.fgmUpdates;
    this.fgmTime = aSrc.fgmTime;
    this.fgm = aSrc.fgm ? Vector.create(aSrc.fgm && aSrc.fgm.elements) : null;
    this.thrust = aSrc.thrust ? Vector.create(aSrc.thrust.elements) : null;
    this.thrustMax = aSrc.thrustMax;
    this.rot = aSrc.thrust ? Vector.create(aSrc.rot.elements) : null;
    this.model = aSrc.model;
    this.refuel = aSrc.refuel;
    this.lidarable = aSrc.lidarable;
    this.maxRenderDistance = aSrc.maxRenderDistance;
    this.maxModelRenderDistance = aSrc.maxModelRenderDistance;
    if (Object.keys(this).sort().join(',') !== Object.keys(aSrc).sort().join(',')) {
        console.error('different go properties');
        console.warn('src', Object.keys(aSrc).sort().join(','), aSrc);
        console.warn('dst', Object.keys(this).sort().join(','), this);
    }
};

SC.go.prototype.debug = function () {
    // Print GO to console
    console.log(this.name + ': pos=' + this.pos.inspect() + ' speed=' + this.speed.inspect() + ' radius=' + this.radius + ' mass=' + this.mass);
};

SC.go.prototype.up = function () {
    // return calculated UP vector
    return this.dir.cross(this.right).toUnitVector();
};

SC.go.prototype.stop = function () {
    // stop rotation
    if (this.rot) {
        this.rot = Vector.create([0, 0, 0]);
    }
};

SC.go.prototype.face = function (aTarget) {
    // rotate to face target
    if (typeof aTarget === 'string') {
        aTarget = SC.gos.findByName(aTarget);
    }
    var s = aTarget.pos.subtract(this.pos).toUnitVector();
    if (s.modulus() < 0.9) {
        s = Vector.i.dup();
    }
    this.dir = s;
    this.right = this.dir.cross(Vector.k.multiply(-1));
    if (this.right.modulus() < 0.9) {
        this.right = Vector.j.dup();
    }
};

SC.go.prototype.teleport = function (aTarget, aDistance) {
    // move to target, adjust speed, face it (for faster mission testing)
    if (typeof aTarget === 'string') {
        aTarget = SC.gos.findByName(aTarget);
    }
    this.pos = aTarget.pos.add(aTarget.dir.multiply(aDistance || (2 * aTarget.radius)));
    this.speed = aTarget.speed.dup();
    this.face(aTarget);
    //SC.target = aTarget;
    SC.gos.updateFgm(true);
};

SC.go.prototype.teleportNear = function (aTarget, aDistanceFrom, aDistanceTo) {
    // move randomly near target (in meters)
    if (typeof aTarget === 'string') {
        aTarget = SC.gos.findByName(aTarget);
    }
    if (aDistanceTo === undefined) {
        aDistanceTo = aDistanceFrom;
    }
    var r = Vector.create([
            Math.random() - Math.random(),
            Math.random() - Math.random(),
            Math.random() - Math.random()
        ]).toUnitVector();
    if (r.modulus() < 0.5) {
        r = Vector.j.dup();
    }
    this.pos = aTarget.pos.add(r.multiply(aDistanceFrom + Math.random() * (aDistanceTo - aDistanceFrom)));
    this.speed = aTarget.speed.dup();
    this.face(aTarget);
};

SC.go.prototype.distanceTo = function (aTarget) {
    // return distance to target
    return aTarget.pos.subtract(this.pos).modulus();
};

SC.go.prototype.rollDegrees = function (aDegrees) {
    // roll by aDegrees
    var x = Math.sin(SC.degToRad(-aDegrees - 90)),
        y = Math.cos(SC.degToRad(-aDegrees - 90)),
        p = this.pos.add(this.up().multiply(y)).add(this.right.multiply(x));
    this.right = this.pos.subtract(p).toUnitVector();
};

SC.go.prototype.yawDegrees = function (aDegrees) {
    // yaw by aDegrees
    var x = Math.sin(SC.degToRad(aDegrees)),
        y = Math.cos(SC.degToRad(aDegrees)),
        d = this.pos.add(this.dir.multiply(y)).add(this.right.multiply(x)),
        r = this.pos.add(this.right.multiply(y)).add(this.dir.multiply(-x));
    this.dir = d.subtract(this.pos).toUnitVector();
    this.right = r.subtract(this.pos).toUnitVector();
};

SC.go.prototype.pitchDegrees = function (aDegrees) {
    // pitch by aDegrees
    var x = Math.sin(SC.degToRad(-aDegrees)),
        y = Math.cos(SC.degToRad(-aDegrees)),
        d = this.pos.add(this.dir.multiply(y)).add(this.up().multiply(x));
    this.dir = d.subtract(this.pos).toUnitVector();
};

// all objects

SC.gos = (function () {
    var self = {};
    self.stop = false;
    self.items = [];
    self.updateCount = 0;
    self.updateFgmCount = 0;
    self.updateFgmLastTime = -5; // Last internal time when fgm was updated
    self.updateFgmSpentTime = 0; // time spent updating FGM

    self.clear = function () {
        // Clear gos
        self.stop = false;
        self.items = [];
        self.updateCount = 0;
        self.updateFgmCount = 0;
        self.updateFgmLastTime = -5;
        self.updateFgmSpentTime = 0;
    };

    self.findByNameCalls = 0; // just to check it's not called in main loops

    self.findByName = function (aName) {
        // find item by name (TODO: consider making it assoc array)
        self.findByNameCalls++;
        var i;
        for (i = 0; i < self.items.length; i++) {
            if (self.items[i].name === aName) {
                return self.items[i];
            }
        }
        return null;
    };

    self.findNearestFrom = function (aFromObject) {
        // find objects sorted by nearest (from given object)
        var i, d, a = [];
        for (i = 0; i < self.items.length; i++) {
            if (self.items[i] !== aFromObject) {
                d = self.items[i].pos.subtract(aFromObject.pos).modulus();
                a.push({d: d, o: self.items[i]});
            }
        }
        a.sort(function (a, b) { return a.d - b.d; });
        return a;
    };

    self.updateFgm = function (aForceUpdate) {
        // recalculate f*g/m for every object, this need to be called only every few minutes
        var t, i, j, ij, r, g, fgm;
        if (self.items.length <= 0) {
            return false;
        }
        // only update every 5s
        if (!aForceUpdate && (SC.time.s - self.updateFgmLastTime < 5)) {
            //console.log('updateFgm not necessary yet');
            return false;
        }
        t = Date.now();
        //console.log('updatingFgm after ' + (t - self.updateFgmLastTime));
        self.updateFgmCount++;
        self.updateFgmLastTime = SC.time.s;
        // all items
        for (i = 0; i < self.items.length; i++) {
            // F = m * a, a = dv / dt ==> dv = a * dt = (F / m) * dt
            // recalculate f
            fgm = Vector.create([0, 0, 0]);
            for (j = 0; j < self.items.length; j++) {
                if (i !== j) {
                    // NOTE: perhaps if i > j distance can be calculated only once
                    ij = self.items[j].pos.subtract(self.items[i].pos);
                    r = ij.modulus();
                    // NOTE: First I multiply by [i].mass then I divide it in dv, so perhaps it can be ommited
                    g = 6.687e-11 * self.items[i].mass * self.items[j].mass / r / r;
                    fgm = fgm.add(ij.toUnitVector().multiply(g / self.items[i].mass));
                }
            }
            self.items[i].fgm = fgm;
        }
        self.updateFgmSpentTime += Date.now() - t;
        return true;
    };

    self.update = function () {
        // update all objects
        var dt = SC.time.update(),
            dv,
            ds,
            i,
            up;
        if (self.stop) {
            return;
        }
        self.updateCount++;

        // update Fgm if necessary
        self.updateFgm();

        // update all items
        for (i = 0; i < self.items.length; i++) {
            // update speed
            // dv = (F * g / m) * dt = Fgm * dt
            dv = self.items[i].fgm.multiply(dt);
            self.items[i].speed = self.items[i].speed.add(dv);
            // apply thrust (F = m * a = m * dv / dt, ==> dv = dt * F / m)
            if (self.items[i].thrust && self.items[i].fuel > 0) {
                dv = self.items[i].thrust.multiply(dt / (self.items[i].mass + self.items[i].fuel));
                //console.log(dv.inspect()+' = '+dv.modulus().toFixed(6));
                self.items[i].speed = self.items[i].speed.add(dv);
                // fuel
                self.items[i].fuel -= dt * (self.items[i].thrust.modulus() / self.items[i].thrustMax) * self.items[i].fuelConsumption;
                if (self.items[i].fuel < 0) {
                    self.items[i].fuel = 0;
                }
            }
            // update position
            // ds = v * dt
            ds = self.items[i].speed.multiply(dt);
            //console.log('ds=' + ds.inspect());
            self.items[i].pos = self.items[i].pos.add(ds);
            // update rotation
            if (self.items[i].rot) {
                // 0 = roll (right = right + q * up)
                up = self.items[i].up();
                self.items[i].right = self.items[i].right.add(up.multiply(dt * self.items[i].rot.elements[0])).toUnitVector();
                // 1 = pitch
                up = self.items[i].up();
                self.items[i].dir = self.items[i].dir.add(up.multiply(dt * self.items[i].rot.elements[1])).toUnitVector();
                // 2 = yaw
                self.items[i].dir = self.items[i].dir.add(self.items[i].right.multiply(dt * self.items[i].rot.elements[2])).toUnitVector();
                self.items[i].right = up.cross(self.items[i].dir);
            }
        }

        // custom update (e.g. pad locked to surface)
        if (self.afterUpdate) {
            self.afterUpdate();
        }
    };

    self.place = function (aName, aCircularOrbit, aCustomSpec) {
        // create initial position and speed vector for one object
        var obj = aCustomSpec || SC.solarSystem.data[aName], parent, pos, speed, po, dir, right, x, y, item;
        if (!obj) {
            throw "Object not found: " + aName;
        }
        // sane defaults
        obj.parent = obj.parent || 'Sun';
        obj.distance = obj.distance || 1.496e11;
        obj.phase = obj.phase || 0;
        obj.mass = obj.mass || 1;
        obj.fuel = obj.fuel || 0;
        obj.speed = obj.speed || 0;
        obj.radius = obj.radius || 1;
        obj.color = obj.color || 'red';
        //console.log('obj', obj);
        // find parent in gos
        parent = self.findByName(obj.parent);
        if (!parent && aName === 'Sun') {
            parent = {
                mass: 0,
                pos: Vector.create([0, 0, 0]),
                speed: Vector.create([0, 0, 0])
            };
        }
        if (!parent) {
            throw "No parent " + obj.parent + " for " + aName;
        }
        pos = parent.pos.dup();
        // calculate phase
        x = obj.distance * Math.sin(SC.degToRad(obj.phase));
        y = obj.distance * Math.cos(SC.degToRad(obj.phase));
        //console.log('phase=' + SC.degToRad(obj.phase));
        pos = pos.add(Vector.create([x, y, 0]));
        // calculate parent-object vector "po"
        po = pos.subtract(parent.pos);
        // calculate circular orbital speed
        if (aCircularOrbit) {
            obj.speed = Math.sqrt(6.67259e-11 * parent.mass / obj.distance);
            //console.log('Circular orbital speed for', aName, 'around', obj.parent, 'is', obj.speed.toFixed(0));
        }
        //console.log('po=' + po.inspect());
        // speed vector is orthogonal to "po" and "up"
        speed = po.cross(Vector.k).toUnitVector().multiply(obj.speed);
        //console.log('speed1=' + speed.inspect());
        // accumulate speed with parent
        speed = speed.add(parent.speed);
        //console.log('speed2=' + speed.inspect());
        dir = speed.toUnitVector();
        right = dir.cross(Vector.k.multiply(-1));
        // create and push item
        item = new SC.go(aName, pos, dir, right, speed, obj.radius, obj.mass, obj.color);
        self.items.push(item);
        // extra params
        item.refuel = obj.refuel || false;
        item.model = obj.model || undefined;
        item.frequency = obj.frequency;
        return item;
    };

    self.placeCustom = function (aCustomSpec) {
        // Place custom object on circular orbit
        SC.fasttext.prepare(aCustomSpec.name, aCustomSpec.color || 'white', 10);
        return self.place(aCustomSpec.name, true, aCustomSpec);
    };

    self.radioSources = function () {
        // Return all radio sources {freq1: obj1, freq2: obj2}
        var i, s = {};
        for (i = 0; i < self.items.length; i++) {
            if (self.items[i].frequency) {
                s[self.items[i].frequency] = self.items[i];
            }
        }
        return s;
    };

    return self;
}());

